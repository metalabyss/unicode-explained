4. Отличия UTF-8 и UTF-16
=========================

4.1. Объем используемой памяти
------------------------------

Первое, за что непроизвольно цепляется внимание, — эффективность кодировок по объему занимаемой памяти. Для UTF-8 требуется от 1 до 4 байт, чтобы закодировать одну позицию, для UTF-16 необходимо либо 2, либо 4 байта. Поскольку кодовые позиции в плоскостях группируются по наборам символов и алфавитам, то эффективность кодирования будет зависеть от используемого алфавита или набора символов. Зная алгоритмы кодирования, нетрудно получить такую таблицу:

| № | Диапазон кодовых точек | UTF-8   | UTF-16  |
|---|------------------------|---------|---------|
| 1 | U+000000 - 00007F      | 1 байт  | 2 байта |
| 2 | U+000080 - 0007FF      | 2 байта | 2 байта |
| 3 | U+000800 - 00FFFF      | 3 байта | 2 байта |
| 4 | U+010000 - 10FFFF      | 4 байта | 4 байта |

Если предполагается использование только ASCII-символов (диапазон №1), то выгоднее покажет себя UTF-8.

Расширенная латиница (используемая в европейских языках), греческая, кириллическая и арабская письменности, иврит, а также знаки пунктуации — все они находятся в диапазоне №2. Следовательно, вне зависимости от используемой кодировки, для кодирования будет использоваться 2 байта.

Современная китайская, японская, корейская письменности имеют кодовые позиции, начинающиеся с U+2E80, но тем не менее все они находятся в пределах BMP. По таблице можно сделать вывод, что UTF-16 даст выигрыш при кодировании этих языков. Но всё же, использование в текстовом документе исключительно иероглифической письменности, особенно в вебе — слишком редкое явление, поэтому выбор предпочтительнее отдать UTF-8.

Получившие широкое распространение эмоджи лежат в SMP и будут занимать по 4 байта вне зависимости от кодировки.

4.2. Отношение порядка в кодовом пространстве
---------------------------------------------

Из-за наличия суррогатных пар в UTF-16 усложняется работа с текстом в данной кодировке. Дело в том, что символы U+E000..U+FFFF очевидно имеют бо́льшие номера, чем коды, используемые в UTF-16 для суррогатных пар. Но с другой стороны, суррогатные пары представляют кодовые позиции, значения которых явно больше, чем U+FFFF. Как следствие, возникает потребность адаптировать алгоритмы для работы со строками к данной особенности UTF-16 — например, придется усложнить банальное лексикографическое сравнение строк.

В случае использования UTF-8 такой необходимости нет, а сам диапазон суррогатных пар не является для нее допустимыми символами.

4.3. Порядок байт
-----------------

UTF-8 выгодно отличает от UTF-16 тот факт, что проблема порядка байт для нее не актуальна, ведь в качестве слова используются единичные байты. Вне зависимости от архитектуры и операционной системы закодированный текст будет интерпретироваться одинаково.

Использовать UTF-16 для внутреннего представления строк явно не стоит, особенно если планируется низкоуровневая работа с памятью/указателями вкупе с намерением сделать ПО кроссплатформенным (в рамках запуска на машинах, которые используют различный порядок байт).

Чтобы этого избежать проблемы порядка байт, ко всем закодированным последовательностям можно добавлять BOM. Тем не менее всегда есть вероятность об этом забыть, что может повлечь лишние ошибки. Вы уверены, что хотите лишний раз рисковать?